<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Audio Recorder</title>
    
    <script src="libvorbis.js"></script>
    
    <script>
'use strict';

function downloadBlob(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'blob';
    
    xhr.onload = function () {
      resolve(xhr.response)
    };
    
    xhr.onerror = reject;
    
    xhr.send();
  });
}

function getAudioStream() {
  var getUserMedia  =  navigator.getUserMedia
                    || navigator.webkitGetUserMedia
                    || navigator.mozGetUserMedia
                    || navigator.msGetUserMedia;
  
  return new Promise(function (resolve, reject) {
    getUserMedia.call(navigator, { audio: true }, function (stream) {
      resolve(stream);
    }, function (err) {
      reject(err);
    });
  });
}

function captureOGG(stream, quality) {
  var bufferSize = 4 * 1024;
  
  var audioContext = new AudioContext();
  var audioSourceNode = audioContext.createMediaStreamSource(stream);
  var scriptProcessorNode = audioContext.createScriptProcessor(bufferSize);
  
  var channels = 2;
  var sampleRate = audioContext.sampleRate;
  
  var encoder =
    Vorbis.Encoding.createVBR(channels, sampleRate, quality)
    .then(Vorbis.Encoding.writeHeaders);
  
  scriptProcessorNode.onaudioprocess = function (ev) {
    var inputBuffer = ev.inputBuffer;
    var samples = inputBuffer.length;
    
    var ch0 = inputBuffer.getChannelData(0);
    var ch1 = inputBuffer.getChannelData(1);
    
    // script processor reuses buffers; we need to make copies
    ch0 = new Float32Array(ch0);
    ch1 = new Float32Array(ch1);
    
    // Float32Array is not Transferrable
    // so we get the underlying ArrayBuffer
    var buffers = [ch0.buffer, ch1.buffer];
    
    encoder = encoder.then(Vorbis.Encoding.encodeTransfer(samples, buffers));
  };
  
  audioSourceNode.connect(scriptProcessorNode);
  scriptProcessorNode.connect(audioContext.destination);
  
  return {
    stop: function () {
      audioSourceNode.disconnect(scriptProcessorNode);
      scriptProcessorNode.disconnect(audioContext.destination);
      
      return encoder.then(Vorbis.Encoding.finish);
    }
  };
}

window.addEventListener('load', function () {
  var record = document.querySelector('#record');
  var stop = document.querySelector('#stop');
  
  var output = document.querySelector('#output');
  
  var streamRef = null;
  var capture = null;
  
  record.addEventListener('click', function () {
    getAudioStream().then(function (stream) {
      streamRef = stream;
      capture = captureOGG(stream, 0.4)
    });
  });
  
  stop.addEventListener('click', function () {
    var result = capture.stop();
    streamRef.stop();
    
    result.then(function (blob) {
      var url = URL.createObjectURL(blob);
      
      // Android Chrome BUG:
      // need to download local blob for some reason
      return downloadBlob(url);
    }).then(function (blob) {
      var url = URL.createObjectURL(blob);
      
      var au = document.createElement('audio');
      au.controls = true;
      au.src = url;
      
      output.appendChild(au);
    });
  });
});

    </script>
  </head>
  <body>
    <section>
      <button id="record">Record</button>
      <button id="stop">Stop</button>
    </section>
    
    <section id="output">
      
    </section>
  </body>
</html>